"""
Training document generation using python-docx.
Creates professional Word documents with citations and source references.
"""

import logging
import re
from datetime import datetime
from typing import List, Dict, Optional
from docx import Document
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT, WD_LINE_SPACING
from docx.enum.style import WD_STYLE_TYPE

from .source_reference import StepSourceData, SourceReference

logger = logging.getLogger(__name__)


class TrainingDocumentGenerator:
    """Generate professional training documents from processed steps."""
    
    def __init__(self, title: str, metadata: Optional[Dict] = None):
        """
        Initialize document generator.
        
        Args:
            title: Main document title
            metadata: Optional metadata (author, date, version, etc.)
        """
        self.doc = Document()
        self.title = title
        self.metadata = metadata or {}
        
        # Configure document properties
        self.doc.core_properties.title = title
        self.doc.core_properties.author = self.metadata.get("author", "ScriptToDoc")
        self.doc.core_properties.comments = "Generated by ScriptToDoc AI"
        
        # Setup custom styles
        self._setup_styles()
    
    def _setup_styles(self):
        """Configure custom styles for the document."""
        try:
            # Set default document font
            style = self.doc.styles['Normal']
            font = style.font
            font.name = 'Calibri'
            font.size = Pt(11)
            
            # Configure Heading 1 style (for steps)
            heading1 = self.doc.styles['Heading 1']
            heading1.font.size = Pt(16)
            heading1.font.bold = True
            heading1.font.color.rgb = RGBColor(0, 70, 120)
            heading1.paragraph_format.space_before = Pt(12)
            heading1.paragraph_format.space_after = Pt(6)
            
            # Configure Heading 2 style (for subsections)
            heading2 = self.doc.styles['Heading 2']
            heading2.font.size = Pt(14)
            heading2.font.bold = True
            heading2.font.color.rgb = RGBColor(0, 100, 150)
            heading2.paragraph_format.space_before = Pt(10)
            heading2.paragraph_format.space_after = Pt(4)
                
        except Exception as e:
            logger.warning(f"Could not configure styles: {e}")
    
    def add_title_page(self):
        """Add professional title page with enhanced formatting and visual design."""
        # Set page margins for title page (reduced for compactness)
        sections = self.doc.sections
        for section in sections:
            section.top_margin = Inches(1.0)
            section.bottom_margin = Inches(1.0)
            section.left_margin = Inches(1.0)
            section.right_margin = Inches(1.0)
        
        # Add vertical spacing at top (reduced)
        for _ in range(3):
            self.doc.add_paragraph()
        
        # Main title - much larger and more prominent
        title_para = self.doc.add_paragraph()
        title_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        title_para.paragraph_format.space_after = Pt(12)
        
        title_run = title_para.add_run(self.title)
        title_run.font.size = Pt(36)
        title_run.font.bold = True
        title_run.font.color.rgb = RGBColor(0, 70, 120)
        title_run.font.name = 'Calibri'
        
        # Add decorative line under title
        line_para = self.doc.add_paragraph()
        line_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        line_para.paragraph_format.space_before = Pt(4)
        line_para.paragraph_format.space_after = Pt(12)
        line_run = line_para.add_run("‚îÄ" * 50)
        line_run.font.size = Pt(12)
        line_run.font.color.rgb = RGBColor(0, 100, 150)
        
        # Subtitle with better styling
        subtitle = self.metadata.get("subtitle", "Training Documentation")
        subtitle_para = self.doc.add_paragraph()
        subtitle_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        subtitle_para.paragraph_format.space_after = Pt(20)
        
        subtitle_run = subtitle_para.add_run(subtitle)
        subtitle_run.font.size = Pt(18)
        subtitle_run.font.color.rgb = RGBColor(70, 70, 70)
        subtitle_run.italic = True
        subtitle_run.font.name = 'Calibri'
        
        # Add spacing before metadata (reduced)
        for _ in range(2):
            self.doc.add_paragraph()
        
        # Metadata section in a professional box format
        # Create a centered container using a table
        meta_table = self.doc.add_table(rows=0, cols=1)
        meta_table.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        meta_table.style = 'Light List Accent 1'
        
        # Add a header row
        header_row = meta_table.add_row()
        header_cell = header_row.cells[0]
        header_para = header_cell.paragraphs[0]
        header_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        header_run = header_para.add_run("Document Information")
        header_run.font.size = Pt(12)
        header_run.font.bold = True
        header_run.font.color.rgb = RGBColor(0, 70, 120)
        header_cell.paragraphs[0].paragraph_format.space_after = Pt(8)
        
        # Add metadata as centered text blocks
        if self.metadata.get("date"):
            date_str = self.metadata["date"]
        else:
            date_str = datetime.now().strftime("%B %d, %Y")
        
        self._add_metadata_centered(meta_table, f"Generated: {date_str}")
        
        if self.metadata.get("version"):
            self._add_metadata_centered(meta_table, f"Version: {self.metadata['version']}")
        
        if self.metadata.get("author"):
            self._add_metadata_centered(meta_table, f"Author: {self.metadata['author']}")
        
        if self.metadata.get("tone"):
            self._add_metadata_centered(meta_table, f"Tone: {self.metadata['tone']}")
        
        if self.metadata.get("audience"):
            self._add_metadata_centered(meta_table, f"Audience: {self.metadata['audience']}")
        
        # Style the table
        meta_table.autofit = True
        for row in meta_table.rows:
            for cell in row.cells:
                cell.vertical_alignment = 1  # Center vertically
                for paragraph in cell.paragraphs:
                    paragraph.paragraph_format.space_before = Pt(4)
                    paragraph.paragraph_format.space_after = Pt(4)
        
        # Add spacing at bottom (reduced)
        for _ in range(2):
            self.doc.add_paragraph()
        
        # Page break
        self.doc.add_page_break()
        
        logger.info("Added enhanced title page")
    
    def _add_metadata_centered(self, table, text: str):
        """Add a centered metadata row to the table."""
        row = table.add_row()
        cell = row.cells[0]
        para = cell.paragraphs[0]
        para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        run = para.add_run(text)
        run.font.size = Pt(11)
        run.font.color.rgb = RGBColor(50, 50, 50)
    
    def _add_metadata_row(self, table, label: str, value: str):
        """Add a row to metadata table."""
        row = table.add_row()
        label_cell = row.cells[0]
        value_cell = row.cells[1]
        
        label_para = label_cell.paragraphs[0]
        label_run = label_para.add_run(label + ":")
        label_run.bold = True
        label_run.font.size = Pt(10)
        label_para.alignment = WD_PARAGRAPH_ALIGNMENT.RIGHT
        
        value_para = value_cell.paragraphs[0]
        value_run = value_para.add_run(value)
        value_run.font.size = Pt(10)
        value_para.alignment = WD_PARAGRAPH_ALIGNMENT.LEFT
    
    def add_table_of_contents(self, steps: List[Dict]):
        """
        Add table of contents with actual step titles.
        
        Note: Word can auto-generate a TOC from headings. This creates a manual TOC
        with actual step titles. Users can replace it with Word's built-in TOC field
        (References > Table of Contents) for auto-updating with page numbers.
        The document uses proper heading styles (Heading 1, Heading 2) so Word can generate it.
        
        Args:
            steps: List of step dictionaries with 'title' field
        """
        self.doc.add_heading("Table of Contents", level=1)
        
        intro_para = self.doc.add_paragraph(
            "This document contains the following sections. "
            "To generate an auto-updating table of contents with page numbers, "
            "use Word's References > Table of Contents feature.\n"
        )
        intro_para.italic = True
        intro_para.space_after = Pt(8)
        
        # Create a structured list
        toc_list = self.doc.add_paragraph("Document Sections:", style='List Bullet')
        toc_list.runs[0].bold = True
        
        # List steps with actual titles
        for i, step in enumerate(steps, 1):
            step_title = step.get('title', 'Untitled Step')
            step_item = self.doc.add_paragraph(
                f"Step {i}: {step_title}",
                style='List Bullet 2'
            )
            step_item.paragraph_format.left_indent = Inches(0.5)
            step_item.runs[0].font.size = Pt(10)
        
        # Add other sections
        self.doc.add_paragraph("Source References", style='List Bullet')
        self.doc.add_paragraph("Document Statistics", style='List Bullet')
        
        # Add note about auto-generation
        note_para = self.doc.add_paragraph()
        note_para.space_before = Pt(12)
        note_run = note_para.add_run(
            "Note: This is a manual table of contents. Use Word's Table of Contents feature "
            "(References > Table of Contents) to generate an auto-updating TOC with page numbers."
        )
        note_run.font.size = Pt(9)
        note_run.font.color.rgb = RGBColor(100, 100, 100)
        note_run.italic = True
        
        # Page break
        self.doc.add_page_break()
        
        logger.info(f"Added table of contents with {len(steps)} steps")
    
    def add_introduction_section(self, step_count: int, overview: Optional[str] = None):
        """
        Add an introduction/overview section after TOC.
        
        Args:
            step_count: Total number of training steps
            overview: Optional overview text
        """
        self.doc.add_heading("Introduction", level=1)
        
        # Overview paragraph
        if overview:
            overview_para = self.doc.add_paragraph(overview)
            overview_para.paragraph_format.space_after = Pt(8)
            overview_para.paragraph_format.line_spacing = 1.15
        else:
            default_overview = (
                "This training document provides step-by-step instructions "
                f"based on a meeting transcript. It contains {step_count} comprehensive steps "
                "designed to guide you through the process described in the source material."
            )
            overview_para = self.doc.add_paragraph(default_overview)
            overview_para.paragraph_format.space_after = Pt(8)
            overview_para.paragraph_format.line_spacing = 1.15
        
        # Document structure section
        structure_heading = self.doc.add_paragraph()
        structure_heading.paragraph_format.space_before = Pt(6)
        structure_label = structure_heading.add_run("Document Structure:")
        structure_label.bold = True
        structure_label.font.size = Pt(11)
        structure_label.font.color.rgb = RGBColor(50, 50, 50)
        structure_heading.space_after = Pt(4)
        
        # Structure list
        structure_items = [
            f"Training Steps: {step_count} detailed steps with clear instructions",
            "Source References: Complete citations supporting each step",
            "Document Statistics: Quality metrics and processing information"
        ]
        
        for item in structure_items:
            item_para = self.doc.add_paragraph(item, style='List Bullet')
            item_para.paragraph_format.left_indent = Inches(0.5)
            item_para.paragraph_format.space_after = Pt(3)
            item_para.runs[0].font.size = Pt(10)
        
        # How to use section
        usage_heading = self.doc.add_paragraph()
        usage_heading.paragraph_format.space_before = Pt(8)
        usage_label = usage_heading.add_run("How to Use This Document:")
        usage_label.bold = True
        usage_label.font.size = Pt(11)
        usage_label.font.color.rgb = RGBColor(50, 50, 50)
        usage_heading.space_after = Pt(4)
        
        usage_items = [
            "Follow the steps sequentially from Step 1 onwards",
            "Each step includes an overview, detailed instructions, and key actions",
            "Refer to the Source References section for original transcript excerpts"
        ]
        
        for item in usage_items:
            item_para = self.doc.add_paragraph(item, style='List Bullet')
            item_para.paragraph_format.left_indent = Inches(0.5)
            item_para.paragraph_format.space_after = Pt(3)
            item_para.runs[0].font.size = Pt(10)
        
        # Add spacing before steps section (reduced)
        self.doc.add_paragraph()
        
        # Section break heading
        steps_heading = self.doc.add_heading("Training Steps", level=1)
        steps_heading.paragraph_format.space_before = Pt(4)
        
        logger.info("Added introduction section")
    
    def add_step(
        self,
        step_number: int,
        step_data: Dict,
        source_data: StepSourceData
    ):
        """
        Add a complete training step.

        Format:
        Step N: [Title]

        Overview: [Summary]

        [Details paragraph]

        Key Actions:
          ‚Ä¢ Action 1
          ‚Ä¢ Action 2
          ‚Ä¢ Action 3

        Args:
            step_number: Step number (1-based)
            step_data: Dictionary with title, summary, details, actions
            source_data: Source reference data for the step
        """
        # Step heading (uses Heading 1 style for TOC)
        step_title = f"Step {step_number}: {step_data.get('title', 'Untitled')}"
        heading = self.doc.add_heading(step_title, level=1)
        
        # Add spacing after heading
        self.doc.paragraphs[-1].paragraph_format.space_after = Pt(6)
        
        # Overview section with enhanced formatting
        if step_data.get('summary'):
            overview_para = self.doc.add_paragraph()
            overview_para.paragraph_format.space_before = Pt(4)
            overview_para.paragraph_format.left_indent = Inches(0.2)
            overview_para.paragraph_format.right_indent = Inches(0.2)
            
            # Add a subtle background effect using border-like formatting
            overview_label = overview_para.add_run("üìã Overview: ")
            overview_label.bold = True
            overview_label.font.size = Pt(11)
            overview_label.font.color.rgb = RGBColor(0, 70, 120)
            overview_text = overview_para.add_run(step_data['summary'])
            overview_text.font.size = Pt(11)
            overview_text.font.color.rgb = RGBColor(30, 30, 30)
            overview_para.space_after = Pt(6)
        
        # Details section with code block detection and formatting
        if step_data.get('details'):
            self._add_text_with_code_formatting(step_data['details'])
        
        # Key Actions section with improved formatting
        if step_data.get('actions'):
            actions_heading = self.doc.add_paragraph()
            actions_heading.paragraph_format.space_before = Pt(6)
            actions_label = actions_heading.add_run("‚úÖ Key Actions:")
            actions_label.bold = True
            actions_label.font.size = Pt(11)
            actions_label.font.color.rgb = RGBColor(0, 100, 150)
            actions_heading.space_after = Pt(4)
            
            # Use numbered list for better clarity
            for idx, action in enumerate(step_data['actions'], 1):
                action_para = self.doc.add_paragraph()
                action_para.paragraph_format.left_indent = Inches(0.5)
                action_para.paragraph_format.space_after = Pt(4)
                
                # Add number and action
                number_run = action_para.add_run(f"{idx}. ")
                number_run.bold = True
                number_run.font.size = Pt(10)
                number_run.font.color.rgb = RGBColor(0, 70, 120)
                
                action_run = action_para.add_run(action)
                action_run.font.size = Pt(10)
                action_run.font.color.rgb = RGBColor(40, 40, 40)
        
        # Confidence indicators and quality metrics removed per user request
        # Steps now display only the core content without confidence scores
        
        # Add horizontal rule for visual separation (using paragraph with border)
        separator_para = self.doc.add_paragraph()
        separator_para.paragraph_format.space_before = Pt(8)
        separator_para.paragraph_format.space_after = Pt(8)
        separator_run = separator_para.add_run("_" * 80)
        separator_run.font.size = Pt(6)
        separator_run.font.color.rgb = RGBColor(200, 200, 200)
        
        logger.info(f"Added step {step_number}: {step_data.get('title', 'Untitled')}")
    
    def add_reference_section(self, all_step_sources: List[StepSourceData]):
        """
        Add appendix with full source excerpts.

        Format:
        SOURCE REFERENCES

        Step 1 - Transcript (Sentence 5)
        "Full transcript excerpt here..."

        Step 1 - Knowledge (Azure Docs)
        External reference content...

        Args:
            all_step_sources: List of all step source data
        """
        # Page break before references
        self.doc.add_page_break()
        
        # Section heading
        self.doc.add_heading("Source References", level=1)
        
        intro = self.doc.add_paragraph(
            "This section provides the complete source references that support "
            "each training step. Each citation includes the original content "
            "from the source material."
        )
        intro.paragraph_format.line_spacing = 1.15
        intro.space_after = Pt(8)

        # Add a note about source types
        note_para = self.doc.add_paragraph()
        note_label = note_para.add_run("Source Types: ")
        note_label.bold = True
        note_label.font.size = Pt(10)
        note_label.font.color.rgb = RGBColor(0, 70, 120)

        note_text = note_para.add_run(
            "Transcript sources are excerpts from the original meeting transcript. "
            "Knowledge sources are external references that provide additional context."
        )
        note_text.font.size = Pt(9)
        note_text.font.color.rgb = RGBColor(100, 100, 100)
        note_text.italic = True
        note_para.space_after = Pt(8)
        
        # Add sources for each step
        for step_sources in all_step_sources:
            if not step_sources.sources:
                continue
            
            # Step heading (uses Heading 2 for TOC)
            step_heading = self.doc.add_heading(
                f"Step {step_sources.step_index} Sources",
                level=2
            )

            # Add step-level summary (without confidence)
            step_summary = self.doc.add_paragraph()
            step_summary.paragraph_format.space_before = Pt(4)
            summary_text = f"Total sources: {len(step_sources.sources)}"
            summary_run = step_summary.add_run(summary_text)
            summary_run.font.size = Pt(9)
            summary_run.font.color.rgb = RGBColor(100, 100, 100)
            summary_run.italic = True
            step_summary.space_after = Pt(8)
            
            # Add each source with better formatting (only text-based sources)
            text_sources = [s for s in step_sources.sources if s.type in ["transcript", "knowledge"]]
            for i, source in enumerate(text_sources, 1):
                # Source type and location with better formatting
                source_label = self._format_source_label(source)
                source_icon = "üìÑ" if source.type == "transcript" else "üåê"
                
                label_para = self.doc.add_paragraph()
                label_para.paragraph_format.space_before = Pt(8)
                label_para.paragraph_format.left_indent = Inches(0.2)
                
                label_icon = label_para.add_run(f"{source_icon} ")
                label_icon.font.size = Pt(11)
                
                label_num = label_para.add_run(f"Source {i}: ")
                label_num.bold = True
                label_num.font.size = Pt(10)
                label_num.font.color.rgb = RGBColor(0, 70, 120)
                
                label_type = label_para.add_run(source_label)
                label_type.bold = True
                label_type.font.size = Pt(10)
                label_type.font.color.rgb = RGBColor(50, 50, 50)
                
                # Source excerpt (as quote) with better formatting
                quote_para = self.doc.add_paragraph()
                quote_para.paragraph_format.left_indent = Inches(0.5)
                quote_para.paragraph_format.right_indent = Inches(0.5)
                quote_para.paragraph_format.space_before = Pt(4)
                quote_para.paragraph_format.space_after = Pt(4)
                
                quote_text = f'"{source.excerpt}"'
                quote_run = quote_para.add_run(quote_text)
                quote_run.font.size = Pt(10)
                quote_run.font.italic = True
                quote_run.font.color.rgb = RGBColor(60, 60, 60)

                # Spacing between sources (confidence removed)
                self.doc.add_paragraph()
        
        logger.info(f"Added source references for {len(all_step_sources)} steps")
    
    def add_summary_statistics(self, statistics: Dict):
        """
        Add document statistics and quality metrics in a professional table format.
        
        Args:
            statistics: Dict with metrics like avg_confidence, total_steps, etc.
        """
        self.doc.add_page_break()
        
        self.doc.add_heading("Document Statistics", level=1)
        
        intro_para = self.doc.add_paragraph(
            "This section provides an overview of the document quality metrics "
            "and processing statistics. These metrics help assess the reliability "
            "and completeness of the generated training steps."
        )
        intro_para.paragraph_format.line_spacing = 1.15
        intro_para.space_after = Pt(8)
        
        # Add a visual separator
        separator_para = self.doc.add_paragraph()
        separator_run = separator_para.add_run("‚îÄ" * 60)
        separator_run.font.size = Pt(6)
        separator_run.font.color.rgb = RGBColor(200, 200, 200)
        separator_para.space_after = Pt(8)
        
        # Create statistics table with header
        stats_table = self.doc.add_table(rows=0, cols=2)
        stats_table.style = 'Light Grid Accent 1'
        
        # Add header row
        header_row = stats_table.add_row()
        header_row.cells[0].paragraphs[0].add_run("Metric").bold = True
        header_row.cells[0].paragraphs[0].runs[0].font.size = Pt(11)
        header_row.cells[0].paragraphs[0].runs[0].font.color.rgb = RGBColor(0, 70, 120)
        header_row.cells[1].paragraphs[0].add_run("Value").bold = True
        header_row.cells[1].paragraphs[0].runs[0].font.size = Pt(11)
        header_row.cells[1].paragraphs[0].runs[0].font.color.rgb = RGBColor(0, 70, 120)
        
        # Style header row
        for cell in header_row.cells:
            cell.vertical_alignment = 1  # Center vertically
            for paragraph in cell.paragraphs:
                paragraph.paragraph_format.space_before = Pt(6)
                paragraph.paragraph_format.space_after = Pt(6)
        
        # Add metric rows (confidence metrics removed per user request)
        self._add_stat_row(stats_table, "Total Steps", str(statistics.get('total_steps', 0)))

        self._add_stat_row(
            stats_table,
            "Total Source References",
            str(statistics.get('total_sources', 0))
        )
        
        processing_time = statistics.get('processing_time', 'N/A')
        if isinstance(processing_time, (int, float)):
            if processing_time < 60:
                time_str = f"{processing_time:.1f} seconds"
            else:
                minutes = int(processing_time // 60)
                seconds = int(processing_time % 60)
                time_str = f"{minutes}m {seconds}s"
        else:
            time_str = str(processing_time)
        
        self._add_stat_row(stats_table, "Processing Time", time_str)
        
        # Token usage statistics
        token_usage = statistics.get('token_usage', {})
        if token_usage:
            input_tokens = token_usage.get('input_tokens', 0)
            output_tokens = token_usage.get('output_tokens', 0)
            total_tokens = token_usage.get('total_tokens', input_tokens + output_tokens)
            
            self._add_stat_row(stats_table, "Input Tokens", f"{input_tokens:,}")
            self._add_stat_row(stats_table, "Output Tokens", f"{output_tokens:,}")
            self._add_stat_row(stats_table, "Total Tokens", f"{total_tokens:,}")
            
            # Calculate and display cost
            estimated_cost = self._calculate_cost_from_tokens(input_tokens, output_tokens)
            if estimated_cost > 0:
                cost_color = RGBColor(0, 120, 0)  # Green for cost
                self._add_stat_row(stats_table, "Estimated Cost", f"${estimated_cost:.4f}", cost_color)
        
        # Auto-fit table
        stats_table.autofit = True
        
        # Add summary paragraph
        summary_para = self.doc.add_paragraph()
        summary_para.space_before = Pt(8)
        summary_para.paragraph_format.first_line_indent = Inches(0.25)

        total_steps = statistics.get('total_steps', 0)
        total_sources = statistics.get('total_sources', 0)

        if total_steps > 0:
            summary_text = (
                f"This document contains {total_steps} training steps "
                f"supported by {total_sources} source references from the original transcript."
            )
        else:
            summary_text = "No steps were generated for this document."

        summary_para.add_run(summary_text)
        summary_para.runs[0].font.size = Pt(10)
        summary_para.runs[0].font.color.rgb = RGBColor(70, 70, 70)
        
        logger.info("Added enhanced statistics section")
    
    def add_knowledge_sources_section(self, knowledge_sources: List[Dict]):
        """
        Add a dedicated section listing all knowledge sources used.
        
        Args:
            knowledge_sources: List of knowledge source dictionaries
        """
        # Filter out failed sources
        successful_sources = [s for s in knowledge_sources if not s.get("error")]
        
        if not successful_sources:
            return  # Don't add section if no successful sources
        
        # Page break before knowledge sources
        self.doc.add_page_break()
        
        # Section heading
        self.doc.add_heading("Knowledge Sources", level=1)
        
        intro = self.doc.add_paragraph(
            "This section lists all external knowledge sources that were used to enhance "
            "and validate the training steps in this document. These sources provide "
            "additional context, best practices, and detailed information beyond the "
            "original transcript."
        )
        intro.paragraph_format.line_spacing = 1.15
        intro.space_after = Pt(12)
        
        # Add each knowledge source
        for idx, source in enumerate(successful_sources, 1):
            url = source.get("url", "")
            title = source.get("title", "Untitled")
            content = source.get("content", "")
            source_type = source.get("type", "unknown")
            search_query = source.get("search_query")
            
            # Source heading
            source_heading = self.doc.add_heading(f"Source {idx}: {title}", level=2)
            source_heading.paragraph_format.space_before = Pt(10)
            source_heading.paragraph_format.space_after = Pt(4)
            
            # Source metadata
            meta_para = self.doc.add_paragraph()
            meta_para.paragraph_format.left_indent = Inches(0.2)
            
            # URL
            url_label = meta_para.add_run("URL: ")
            url_label.bold = True
            url_label.font.size = Pt(10)
            url_label.font.color.rgb = RGBColor(0, 70, 120)
            
            url_text = meta_para.add_run(url)
            url_text.font.size = Pt(10)
            url_text.font.color.rgb = RGBColor(0, 100, 200)
            
            # Type
            type_para = self.doc.add_paragraph()
            type_para.paragraph_format.left_indent = Inches(0.2)
            type_label = type_para.add_run("Type: ")
            type_label.bold = True
            type_label.font.size = Pt(10)
            type_label.font.color.rgb = RGBColor(0, 70, 120)
            
            type_text = type_para.add_run(source_type.title())
            type_text.font.size = Pt(10)
            
            # Search query (if from internet search)
            if search_query:
                search_para = self.doc.add_paragraph()
                search_para.paragraph_format.left_indent = Inches(0.2)
                search_label = search_para.add_run("Search Query: ")
                search_label.bold = True
                search_label.font.size = Pt(10)
                search_label.font.color.rgb = RGBColor(0, 70, 120)
                
                search_text = search_para.add_run(f'"{search_query}"')
                search_text.font.size = Pt(10)
                search_text.italic = True
            
            # Content preview
            if content:
                content_para = self.doc.add_paragraph()
                content_para.paragraph_format.space_before = Pt(8)
                content_para.paragraph_format.left_indent = Inches(0.3)
                content_para.paragraph_format.right_indent = Inches(0.3)
                
                content_label = content_para.add_run("Content Preview: ")
                content_label.bold = True
                content_label.font.size = Pt(10)
                content_label.font.color.rgb = RGBColor(0, 70, 120)
                
                # Truncate content for preview (first 500 chars)
                content_preview = content[:500] + "..." if len(content) > 500 else content
                content_text = content_para.add_run(content_preview)
                content_text.font.size = Pt(9)
                content_text.font.color.rgb = RGBColor(70, 70, 70)
                content_text.italic = True
                content_para.space_after = Pt(12)
        
        logger.info(f"Added knowledge sources section with {len(successful_sources)} sources")
    
    def _calculate_cost_from_tokens(self, input_tokens: int, output_tokens: int) -> float:
        """
        Calculate estimated cost based on token usage.
        
        Pricing for GPT-4o-mini (as of 2024):
        - Input: $0.15 per 1M tokens
        - Output: $0.60 per 1M tokens
        
        Args:
            input_tokens: Number of input tokens
            output_tokens: Number of output tokens
            
        Returns:
            Estimated cost in USD
        """
        # GPT-4o-mini pricing (per 1M tokens)
        input_cost_per_million = 0.15
        output_cost_per_million = 0.60
        
        input_cost = (input_tokens / 1_000_000) * input_cost_per_million
        output_cost = (output_tokens / 1_000_000) * output_cost_per_million
        
        total_cost = input_cost + output_cost
        
        return round(total_cost, 4)
    
    def _add_stat_row(self, table, label: str, value: str, value_color: Optional[RGBColor] = None):
        """Add a row to statistics table."""
        row = table.add_row()
        label_cell = row.cells[0]
        value_cell = row.cells[1]
        
        label_para = label_cell.paragraphs[0]
        label_run = label_para.add_run(label + ":")
        label_run.bold = True
        label_run.font.size = Pt(10)
        
        value_para = value_cell.paragraphs[0]
        value_run = value_para.add_run(value)
        value_run.font.size = Pt(10)
        if value_color:
            value_run.font.color.rgb = value_color
    
    def _get_confidence_level(self, confidence: float) -> str:
        """Get human-readable confidence level."""
        if confidence >= 0.85:
            return "Very High"
        elif confidence >= 0.7:
            return "High"
        elif confidence >= 0.5:
            return "Medium"
        elif confidence >= 0.3:
            return "Low"
        else:
            return "Very Low"
    
    def _get_confidence_color(self, confidence: float) -> RGBColor:
        """Get color for confidence level."""
        if confidence >= 0.7:
            return RGBColor(0, 150, 0)  # Green
        elif confidence >= 0.5:
            return RGBColor(200, 150, 0)  # Yellow/Orange
        else:
            return RGBColor(200, 0, 0)  # Red
    
    def _detect_code_blocks(self, text: str) -> List[Dict[str, str]]:
        """
        Detect code blocks in text.
        
        Supports:
        - Markdown code blocks: ```language\\ncode\\n```
        - Inline code: `code`
        - Function/method signatures
        
        Args:
            text: Text that may contain code
            
        Returns:
            List of dicts with 'type', 'code', 'language', 'start', 'end'
        """
        code_blocks = []
        
        # Find markdown code blocks
        markdown_pattern = r'```(\\w*)\\n([^`]+)```'
        for match in re.finditer(markdown_pattern, text, re.MULTILINE | re.DOTALL):
            language = match.group(1) or 'text'
            code = match.group(2).strip()
            code_blocks.append({
                'type': 'block',
                'code': code,
                'language': language,
                'start': match.start(),
                'end': match.end()
            })
        
        # Find inline code (backticks)
        inline_pattern = r'`([^`]+)`'
        for match in re.finditer(inline_pattern, text):
            # Skip if already part of a markdown block
            if not any(cb['start'] <= match.start() < cb['end'] for cb in code_blocks if cb['type'] == 'block'):
                # Only create blocks for longer inline code
                if len(match.group(1)) > 50:
                    code_blocks.append({
                        'type': 'block',
                        'code': match.group(1),
                        'language': 'code',
                        'start': match.start(),
                        'end': match.end()
                    })
        
        # Sort by position
        code_blocks.sort(key=lambda x: x['start'])
        
        return code_blocks
    
    def _add_code_block_to_doc(self, code: str, language: str = 'text'):
        """
        Add a formatted code block to the document.
        
        Args:
            code: Code content
            language: Programming language
        """
        # Add language label
        if language and language != 'text':
            lang_para = self.doc.add_paragraph()
            lang_para.paragraph_format.space_before = Pt(6)
            lang_para.paragraph_format.left_indent = Inches(0.5)
            lang_run = lang_para.add_run(f"{language.upper()}")
            lang_run.bold = True
            lang_run.font.size = Pt(8)
            lang_run.font.color.rgb = RGBColor(100, 100, 100)
        
        # Add code block
        code_para = self.doc.add_paragraph(code)
        code_para.paragraph_format.left_indent = Inches(0.5)
        code_para.paragraph_format.right_indent = Inches(0.5)
        code_para.paragraph_format.space_before = Pt(4)
        code_para.paragraph_format.space_after = Pt(8)
        
        # Style as monospace
        for run in code_para.runs:
            run.font.name = 'Courier New'
            run.font.size = Pt(9)
            run.font.color.rgb = RGBColor(0, 0, 0)
        
        # Add background shading
        try:
            from docx.oxml import OxmlElement
            from docx.oxml.ns import qn
            
            shd = OxmlElement('w:shd')
            shd.set(qn('w:fill'), 'F5F5F5')
            code_para._element.get_or_add_pPr().append(shd)
        except:
            pass
    
    def _add_text_with_code_formatting(self, text: str):
        """
        Add text with code block formatting.
        
        Args:
            text: Text that may contain code blocks
        """
        code_blocks = self._detect_code_blocks(text)
        
        if not code_blocks:
            # No code, add as regular text
            para = self.doc.add_paragraph(text)
            para.paragraph_format.first_line_indent = Inches(0.25)
            para.paragraph_format.space_after = Pt(6)
            para.paragraph_format.line_spacing = 1.15
            return
        
        # Add text segments between code blocks
        last_pos = 0
        
        for cb in code_blocks:
            # Add text before code block
            if cb['start'] > last_pos:
                pre_text = text[last_pos:cb['start']].strip()
                if pre_text:
                    para = self.doc.add_paragraph(pre_text)
                    para.paragraph_format.first_line_indent = Inches(0.25)
                    para.paragraph_format.space_after = Pt(6)
                    para.paragraph_format.line_spacing = 1.15
            
            # Add code block
            self._add_code_block_to_doc(cb['code'], cb['language'])
            
            last_pos = cb['end']
        
        # Add remaining text
        if last_pos < len(text):
            post_text = text[last_pos:].strip()
            if post_text:
                para = self.doc.add_paragraph(post_text)
                para.paragraph_format.first_line_indent = Inches(0.25)
                para.paragraph_format.space_after = Pt(6)
                para.paragraph_format.line_spacing = 1.15
    
    def _format_sources_summary(self, sources: List[SourceReference]) -> str:
        """Format sources summary for inline display (text-only, excludes visual)."""
        transcript_count = sum(1 for s in sources if s.type == "transcript")
        knowledge_count = sum(1 for s in sources if s.type == "knowledge")

        parts = []
        if transcript_count > 0:
            parts.append(f"transcript ({transcript_count})")
        if knowledge_count > 0:
            parts.append(f"knowledge ({knowledge_count})")

        return ", ".join(parts) if parts else "none"
    
    def _format_source_label(self, source: SourceReference) -> str:
        """Format source label for reference section."""
        if source.type == "transcript":
            if source.sentence_index is not None:
                return f"Transcript (Sentence {source.sentence_index + 1})"
            elif source.timestamp:
                return f"Transcript ({source.timestamp})"
            else:
                return "Transcript"
        
        elif source.type == "visual":
            if source.screenshot_ref:
                return f"Visual ({source.screenshot_ref})"
            else:
                return "Visual (Screenshot)"
        
        else:
            return source.type.capitalize()
    
    def save(self, output_path: str) -> str:
        """
        Save document to file.
        
        Args:
            output_path: Path where document should be saved
            
        Returns:
            Path to saved document
        """
        try:
            self.doc.save(output_path)
            logger.info(f"Document saved to: {output_path}")
            return output_path
        except Exception as e:
            logger.error(f"Failed to save document: {e}")
            raise
    
    def get_document(self) -> Document:
        """Get the underlying Document object for advanced manipulation."""
        return self.doc


def create_training_document(
    title: str,
    steps: List[Dict],
    step_sources: List[StepSourceData],
    output_path: str,
    metadata: Optional[Dict] = None,
    include_statistics: bool = True,
    statistics: Optional[Dict] = None,
    knowledge_sources: Optional[List[Dict]] = None
) -> str:
    """
    Convenience function to create a complete training document.
    
    Args:
        title: Document title
        steps: List of step dictionaries
        step_sources: List of source data for each step
        output_path: Where to save the document
        metadata: Optional metadata
        include_statistics: Whether to include statistics page
        
    Returns:
        Path to saved document
    """
    logger.info(f"Creating training document: {title}")
    
    # Create generator
    generator = TrainingDocumentGenerator(title, metadata)
    
    # Add title page
    generator.add_title_page()
    
    # Add TOC with actual step titles
    generator.add_table_of_contents(steps)
    
    # Add introduction section
    generator.add_introduction_section(
        step_count=len(steps),
        overview=metadata.get("overview")
    )
    
    # Add each step
    for i, (step, source_data) in enumerate(zip(steps, step_sources), 1):
        generator.add_step(i, step, source_data)
    
    # Add source references
    generator.add_reference_section(step_sources)
    
    # Add knowledge sources section if provided
    if knowledge_sources:
        generator.add_knowledge_sources_section(knowledge_sources)
    
    # Add statistics if requested
    if include_statistics:
        # Use provided statistics or calculate from step_sources
        if statistics:
            stats = statistics.copy()
            # Ensure we have all required fields
            if "avg_confidence" not in stats:
                if len(step_sources) > 0:
                    stats["avg_confidence"] = sum(s.overall_confidence for s in step_sources) / len(step_sources)
                else:
                    stats["avg_confidence"] = 0.0
            if "high_confidence_count" not in stats:
                stats["high_confidence_count"] = sum(1 for s in step_sources if s.overall_confidence >= 0.7)
            if "visual_support_count" not in stats:
                stats["visual_support_count"] = sum(1 for s in step_sources if s.has_visual_support)
            if "total_sources" not in stats:
                stats["total_sources"] = sum(len(s.sources) for s in step_sources)
            if "total_steps" not in stats:
                stats["total_steps"] = len(steps)
        else:
            # Fallback: calculate from step_sources
            if len(step_sources) > 0:
                avg_confidence = sum(s.overall_confidence for s in step_sources) / len(step_sources)
                high_confidence_count = sum(1 for s in step_sources if s.overall_confidence >= 0.7)
                visual_support_count = sum(1 for s in step_sources if s.has_visual_support)
                total_sources = sum(len(s.sources) for s in step_sources)
            else:
                avg_confidence = 0.0
                high_confidence_count = 0
                visual_support_count = 0
                total_sources = 0
            
            stats = {
                "total_steps": len(steps),
                "avg_confidence": avg_confidence,
                "high_confidence_count": high_confidence_count,
                "visual_support_count": visual_support_count,
                "total_sources": total_sources,
            }
        
        generator.add_summary_statistics(stats)
    
    # Save document
    return generator.save(output_path)

